package {	//import flash.events.MouseEvent;	import flash.events.Event;	import flash.events.IOErrorEvent;	//import flash.display.MovieClip;	import flash.display.Sprite;	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.Shape;	import flash.display.GradientType;	import flash.display.SpreadMethod;	import flash.net.LocalConnection;	import flash.geom.Point;	import flash.geom.Matrix;	import gs.TweenMax;	import net.hires.debug.Logger;	public class Cover extends Sprite	{		private var result:BitmapData;		private var _photo:Sprite = new Sprite();		private var reflection:Sprite = new Sprite();		private var inPt:Point;		private var outPt:Point;		private var inScale:Number;		private var outScale:Number;		private var isOut:Boolean = false;		private var _url:String;		public function get url ():String{return _url;}		public function get photo ():Sprite{return _photo;}		public function set url (url_:String) :void{_url = url_;}		//var duplicate:Bitmap;				//private var frame :Sprite = new Sprite();		public function Cover()		{			_photo = new Sprite();			_photo.mouseEnabled = false;			reflection = new Sprite();			reflection.mouseEnabled = false;			addChild(_photo);			//addChild(reflection);			width = 476;			height = 600;					}		function completeHandler(event:Event):void {			trace("completeHandler "+event);			var s:SmoothingBitmapLoader = event.target as SmoothingBitmapLoader;			var image:Sprite = s.loaderContent as Sprite;			_photo.addChild(image);						_photo.mask = image;			/*			var bmp:Bitmap = createGradientBitmap(_photo,_photo.width,_photo.height);			reflection.addChild(bmp);			reflection.width = _photo.width;			reflection.height = _photo.height;			reflection.y = _photo.height;															reflection.x =  -reflection.width * 0.4;			reflection.y = (_photo.y+_photo.height);*/						dispatchEvent(new Event(Event.COMPLETE));		}		public function setup(path:String , _inPt:Point, _outPt:Point)		{			url = path;			inPt = _inPt;			outPt = _outPt;			this.x = outPt.x;			this.y = outPt.y;			addEventListener(Event.ADDED_TO_STAGE,function onAdded(e:Event):void{				removeEventListener(Event.ADDED_TO_STAGE,onAdded);				var loader:SmoothingBitmapLoader = new SmoothingBitmapLoader(path);				loader.addEventListener(SmoothingBitmapLoader.INIT,handleComplete);				loader.addEventListener(IOErrorEvent.IO_ERROR,function handdleError(e:IOErrorEvent)										{											dispatchEvent(new IOErrorEvent(IOErrorEvent.IO_ERROR));										});											loader.mouseEnabled = false;			 });			addEventListener(Event.REMOVED_FROM_STAGE,function onRemoved(e:Event):void{				removeEventListener(Event.REMOVED_FROM_STAGE,onRemoved);				//Logger.debug(url+" Cover Removed from stage");				if (result!=null)				{					result.dispose();				}				while(_photo.numChildren>0)				{					_photo.removeChildAt(0);				}				while(reflection.numChildren>0)				{					reflection.removeChildAt(0);				}								try {					new LocalConnection().connect('foo');					new LocalConnection().connect('foo');				} catch (e:*){					//Logger.debug("Forcing Garbage Collection :"+e.toString());				}									 });		}		function setFadeInPoint(_inPt:Point)		{			inPt = _inPt;		}		function setFadeOutPoint(_outPt:Point)		{			outPt = _outPt;		}		public function fadeIn(_scale:Number , delay:Number = 0)		{			TweenMax.to(this,0.5,{delay:delay,x:inPt.x,y:inPt.y , scaleX:_scale,scaleY:_scale});		}		function fadeOut(_scale:Number , delay:Number = 0)		{			TweenMax.to(this,0.5,{delay:delay,x:outPt.x,y:outPt.y, scaleX:_scale,scaleY:_scale,onComplete:fadeOutComplete,onCompleteParams:[this]});		}		function fadeOutComplete(arg:*):void		{			//Logger.debug(url+" invisible");			//visible = false;		}		function handleComplete(e:Event)		{			Logger.debug(url+" handleComplete");			var image:SmoothingBitmapLoader = e.target as SmoothingBitmapLoader;			_photo.addChild(image);			_photo.x =  -  476*0.5;//image.width * 0.5;			_photo.y =  -  600*0.5;//image.height ;			_photo.setChildIndex(image,_photo.numChildren-1);			var mask_:SmoothingBitmapLoader = new SmoothingBitmapLoader("./Mask.swf");			mask_.addEventListener(SmoothingBitmapLoader.INIT,completeHandler);		}		function createGradientBitmap(image:Sprite,__width:int , __height:int):Bitmap		{			var bmd:BitmapData= new BitmapData(__width-1,__height-1,true,0x00000000);			if (image!=null)			{				bmd.draw(image);			}			var myImage:Bitmap = new Bitmap(bmd);//Logger.debug("createGradientBitmap");			var matrix:Matrix = new Matrix();			matrix.createGradientBox(__width,__height, Math.PI / 2 );			var linear:String = GradientType.LINEAR;			var colors:Array = [0xFFFFFF,0xFFFFFF];			var alphas:Array = [0.0,0.95];			var ratios:Array = [127,255];			var spread:String = SpreadMethod.PAD;			var gradient:Shape = new Shape();			gradient.graphics.beginGradientFill( linear, colors, alphas, ratios, matrix, spread );			gradient.graphics.drawRect(0, 0, __width,__height);			gradient.graphics.endFill();			var gradientBitmap:BitmapData = new BitmapData(__width,__height,true,0);			gradientBitmap.draw( gradient );			//matrix = new Matrix();			//matrix.translate(-image.width / 2, -image.height / 2);			//matrix.rotate(180 * (Math.PI / 180));			//matrix.translate(image.width / 2, image.height / 2);			var matriximage:BitmapData = new BitmapData(__width,__height,true,0x00000000);			matriximage.draw(image);			//, matrix);			if (result!=null)			{				result.dispose();			}			result = new BitmapData(__width,__height,true,0);			result.copyPixels( matriximage, result.rect, new Point(), gradientBitmap, new Point(), true );			var nBM:Bitmap = new Bitmap(result);			nBM.scaleY *=  -1;			nBM.y = __height;			matriximage.dispose();			gradientBitmap.dispose();			bmd.dispose();			//bmpMemoryArray.push(result);			return (nBM);		}	}}